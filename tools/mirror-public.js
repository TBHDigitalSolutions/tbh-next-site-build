#!/usr/bin/env node
/**
 * Mirror selected subtrees from src/data/* into /public/* (directories only),
 * optionally writing README.md placeholders, and (optionally) pruning anything
 * under those mirrored roots that doesn't belong.
 *
 * Node: >= 18
 *
 * Flags:
 *   --dry-run   : print actions, make no changes
 *   --verbose   : extra logging
 *   --readme    : create/ensure README.md in every mirrored directory
 *   --prune     : remove unexpected paths inside mirrored roots
 *
 * Examples:
 *   node tools/mirror-public.js --readme
 *   node tools/mirror-public.js --readme --dry-run --verbose
 *   node tools/mirror-public.js --readme --prune
 */

const fs = require("fs");
const path = require("path");

const args = new Set(process.argv.slice(2));
const DRY = args.has("--dry-run");
const VERBOSE = args.has("--verbose");
const WRITE_README = args.has("--readme");
const PRUNE = args.has("--prune");

const ROOT = process.cwd();
const SRC = path.resolve(ROOT, "src/data");
const PUBLIC = path.resolve(ROOT, "public");

// top-level src/data subtrees to mirror to /public
const DATA_ROOTS = [
  "booking",
  "caseStudies",
  "composers",
  "modules",
  "packages",
  "page",
  "portfolio",
  "taxonomy",
  "testimonials",
];

// safe allowlist in /public (kept even with --prune)
const PUBLIC_ALLOW_TOP = new Set([
  ".DS_Store",
  "favicon.ico",
  "favicon-16x16.png",
  "favicon-32x32.png",
  "apple-touch-icon.png",
  "android-chrome-192x192.png",
  "android-chrome-512x512.png",
  "site.webmanifest",
  "robots.txt",
  "sitemap.xml",
  "og-image.png",
]);

function log(...m) {
  if (VERBOSE) console.log(...m);
}

function ensureDir(p) {
  if (!fs.existsSync(p)) {
    if (DRY) {
      console.log(`[dry-run] mkdir -p ${p}`);
    } else {
      fs.mkdirSync(p, { recursive: true });
    }
  }
}

function writeFileIfNeeded(filePath, content) {
  if (DRY) {
    console.log(`[dry-run] write ${filePath}`);
    return;
  }
  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, content);
    return;
  }
  const existing = fs.readFileSync(filePath, "utf8");
  if (existing !== content) {
    fs.writeFileSync(filePath, content);
  }
}

function* walkDirs(absDir) {
  // yield all directories under absDir (depth-first)
  const entries = fs.readdirSync(absDir, { withFileTypes: true });
  yield absDir;
  for (const e of entries) {
    if (e.isDirectory()) {
      yield* walkDirs(path.join(absDir, e.name));
    }
  }
}

function relToPublic(absUnderSrcData) {
  // Convert /…/src/data/<X>[/…] → <X>[/…] for public
  const relFromData = path.relative(SRC, absUnderSrcData);
  return relFromData.replace(/\\/g, "/"); // normalize on Windows
}

function listExpected() {
  // Set of directories we expect to exist under /public
  const expectedDirs = new Set();
  // Set of files we expect (currently only README.md when WRITE_README is on)
  const expectedFiles = new Set();

  for (const root of DATA_ROOTS) {
    const abs = path.join(SRC, root);
    if (!fs.existsSync(abs) || !fs.statSync(abs).isDirectory()) continue;

    for (const d of walkDirs(abs)) {
      const relForPublic = relToPublic(d); // e.g. "packages/seo-services"
      const relDir = relForPublic; // directory path under /public
      expectedDirs.add(relDir);

      if (WRITE_README) {
        const readmeRel = path.join(relDir, "README.md").replace(/\\/g, "/");
        expectedFiles.add(readmeRel);
      }
    }
  }
  return { expectedDirs, expectedFiles };
}

function ensureMirror(expectedDirs, expectedFiles) {
  // 1) ensure /public exists
  ensureDir(PUBLIC);
  // 2) create expected directories and readmes
  const sortedDirs = Array.from(expectedDirs).sort();
  for (const rel of sortedDirs) {
    const abs = path.join(PUBLIC, rel);
    ensureDir(abs);

    if (WRITE_README) {
      const readmeAbs = path.join(abs, "README.md");
      const content = `# ${rel}\n\n> Auto-generated by tools/mirror-public.js\n\nThis directory mirrors \`src/data/${rel}\`.\n`;
      writeFileIfNeeded(readmeAbs, content);
    }

    // status line similar to your previous logs
    const segs = rel.split("/");
    if (segs.length === 1) {
      console.log(`Mirror: ${rel}`);
    }
  }
}

function listExistingUnderMirroredRoots() {
  // returns a Set of *relative* paths under /public for all items (files & dirs)
  const out = new Set();
  for (const top of DATA_ROOTS) {
    const abs = path.join(PUBLIC, top);
    if (!fs.existsSync(abs)) continue;
    function walk(p, relBase) {
      const entries = fs.readdirSync(p, { withFileTypes: true });
      for (const e of entries) {
        const rel = path.join(relBase, e.name).replace(/\\/g, "/");
        out.add(rel);
        if (e.isDirectory()) walk(path.join(p, e.name), rel);
      }
    }
    walk(abs, top);
  }
  return out;
}

function pruneUnexpected(expectedDirs, expectedFiles) {
  // only act within the mirrored roots; keep top-level allowed files
  const expectedAll = new Set([...expectedDirs, ...expectedFiles]);

  const existing = listExistingUnderMirroredRoots(); // paths relative to /public
  for (const rel of existing) {
    // Skip top-level files in public allowlist (only applies at root, not inside trees)
    const top = rel.split("/")[0];
    if (!DATA_ROOTS.includes(top)) {
      // shouldn't happen because we only walked mirrored roots, but guard anyway
      continue;
    }

    // directories recorded as-is, files must match expectedFiles
    const abs = path.join(PUBLIC, rel);
    const isDir = fs.existsSync(abs) && fs.statSync(abs).isDirectory();

    // Directories are expected if in expectedDirs
    // Files are expected if in expectedFiles (README.md)
    const isExpected = isDir ? expectedDirs.has(rel) : expectedFiles.has(rel);

    if (!isExpected) {
      if (DRY) {
        console.log(`[dry-run][prune] rm -rf ${abs}`);
      } else {
        // remove file or directory recursively
        fs.rmSync(abs, { recursive: true, force: true });
        console.log(`[prune] removed ${abs}`);
      }
    }
  }
}

function main() {
  // basic guards
  if (!fs.existsSync(SRC) || !fs.statSync(SRC).isDirectory()) {
    console.error(`❌ Not found: ${SRC}`);
    process.exit(1);
  }
  ensureDir(PUBLIC);

  if (DRY) {
    console.log(`[dry-run] mkdir -p ${PUBLIC}`);
  }

  const { expectedDirs, expectedFiles } = listExpected();
  ensureMirror(expectedDirs, expectedFiles);

  if (PRUNE) {
    pruneUnexpected(expectedDirs, expectedFiles);
  }

  console.log("✅ Public mirror is up to date.");
}

main();
