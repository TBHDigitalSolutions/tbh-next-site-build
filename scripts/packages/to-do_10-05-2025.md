Here’s a tight, practical **gap analysis + implementation plan** for your `scripts/packages` toolchain. It lists what’s **already done**, what’s **missing**, and gives you **clear specs + starter templates** for each missing script so you can implement them quickly with the new `src/packages/lib/**` APIs.

---

# Scripts to Create (and how)

## Status map

| Script                          | Status               | Keep / Replace | Notes                                                             |
| ------------------------------- | -------------------- | -------------- | ----------------------------------------------------------------- |
| `build.ts`                      | ✅ Done               | **Keep**       | Orchestrator (pipeline runner).                                   |
| `validate.ts`                   | ✅ Done               | **Keep**       | Merges schema + featured + growth checks.                         |
| `generate-registry-manifest.ts` | ❌ Missing            | **Create**     | Discover all entries via loader; emit minimal manifest JSON.      |
| `build-catalog-json.ts`         | ❌ Missing            | **Create**     | Map validated packages → compact card/grid catalog.               |
| `build-unified-search.ts`       | ❌ Missing            | **Create**     | Build small inverted index + doc list for client/server search.   |
| `packages-stats.ts`             | ❌ Missing            | **Create**     | Compute counts, min/avg/max, by-service stats; write JSON or log. |
| `mdx-to-registry.ts`            | ❌ Missing (optional) | **Create**     | MDX frontmatter → runtime `content.generated.json`.               |
| `mirror-docs-to-registry.ts`    | ❌ Missing (optional) | **Create**     | Copy/sync docs/assets into per-package registry folders.          |
| `doctor.ts`                     | ❌ Missing (optional) | **Create**     | Simple shim: `validate.ts --all`.                                 |

> The older one-off scripts like `build-packages.ts`, `check-featured-refs.ts`, `check-growth-embeds.ts`, `validate-packages.ts` are **superseded** by `build.ts` and `validate.ts`. Keep only if you need legacy CI jobs; otherwise retire.

---

## 1) `scripts/packages/generate-registry-manifest.ts`

**Purpose**
Discover every `content.generated.json` under your registry and emit a **tiny manifest** for fast lookups and incremental tools.

**Reads**

* Registry tree via `discoverPackageEntries()` from `src/packages/lib/registry/loader.ts`

**Writes**

* `src/packages/registry/manifest.generated.json` (default; overridable)

**CLI**

* `--registry-root=<dir>` (default: `src/packages/registry`)
* `--out=<file>` (default: `<registry-root>/manifest.generated.json`)
* `--minify` | `--pretty` (default: pretty)
* `--quiet`

**Output shape (example)**

```json
{
  "generatedAt": "2025-02-15T10:30:45.123Z",
  "count": 24,
  "items": [
    {
      "slug": "local-seo-starter",
      "serviceDir": "seo-services",
      "jsonPath": "src/packages/registry/seo-services/local-seo-starter/content.generated.json"
    }
  ]
}
```

**Starter template**

```ts
// scripts/packages/generate-registry-manifest.ts
import { discoverPackageEntries } from "@/packages/lib/registry/loader";
import fs from "node:fs/promises";
import path from "node:path";

function arg(name: string, def?: string) {
  const hit = process.argv.find((a) => a.startsWith(`${name}=`));
  return hit ? hit.split("=").slice(1).join("=") : def;
}
function has(flag: string) { return process.argv.includes(flag); }
function prettyMaybe(obj: unknown, minify: boolean) {
  return JSON.stringify(obj, null, minify ? 0 : 2);
}

(async () => {
  const registryRoot = arg("--registry-root", "src/packages/registry")!;
  const out = arg("--out", path.join(registryRoot, "manifest.generated.json"))!;
  const minify = has("--minify") && !has("--pretty");
  const quiet = has("--quiet");

  const entries = await discoverPackageEntries({ registryRoot });
  const payload = {
    generatedAt: new Date().toISOString(),
    count: entries.length,
    items: entries.map((e) => ({
      slug: e.slug,
      serviceDir: e.serviceDir,
      jsonPath: path.relative(process.cwd(), e.jsonPath),
    })),
  };

  await fs.mkdir(path.dirname(out), { recursive: true });
  await fs.writeFile(out, prettyMaybe(payload, minify), "utf8");
  if (!quiet) console.log(`✔ manifest → ${out} (${payload.count} items)`);
})().catch((err) => {
  console.error("✖ generate-registry-manifest failed\n", err);
  process.exit(1);
});
```

---

## 2) `scripts/packages/build-catalog-json.ts`

**Purpose**
Produce a **runtime-safe catalog** for hubs/grids: a compact list of card-friendly items (slug, name, summary, price, top features, service, tags).

**Reads**

* Validated packages via `loadAllPackages()`
* View-model mapping via `buildPackageCardProps()` from `mappers/package-mappers.ts`

**Writes**

* `public/generated/packages.catalog.json` (default; overridable)

**CLI**

* `--registry-root=<dir>`
* `--out=<file>` (default: `public/generated/packages.catalog.json`)
* `--minify` | `--pretty` (default: pretty)
* `--limit=<N>` (optional cap during dev)
* `--quiet`

**Output shape (example)**

```json
{
  "generatedAt": "2025-02-15T10:31:00.000Z",
  "count": 24,
  "items": [
    {
      "slug": "local-seo-starter",
      "name": "Local SEO Starter",
      "description": "Drive local visibility...",
      "price": { "monthly": 1200, "oneTime": 750, "currency": "USD" },
      "features": ["GMB optimization","Local citations","Review strategy"],
      "service": "seo-services",
      "tags": ["local","beginner"],
      "href": "/packages/local-seo-starter",
      "badge": "Most Popular"
    }
  ]
}
```

**Starter template**

```ts
// scripts/packages/build-catalog-json.ts
import { loadAllPackages } from "@/packages/lib/registry/loader";
import { buildPackageCardProps } from "@/packages/lib/mappers/package-mappers";
import fs from "node:fs/promises";
import path from "node:path";

function arg(name: string, def?: string) {
  const hit = process.argv.find((a) => a.startsWith(`${name}=`));
  return hit ? hit.split("=").slice(1).join("=") : def;
}
function has(flag: string) { return process.argv.includes(flag); }

(async () => {
  const registryRoot = arg("--registry-root", "src/packages/registry");
  const out = arg("--out", "public/generated/packages.catalog.json")!;
  const limit = Number(arg("--limit", "")) || undefined;
  const minify = has("--minify") && !has("--pretty");
  const quiet = has("--quiet");

  const { items, errors } = await loadAllPackages({ registryRoot });
  if (errors.length) {
    console.error("✖ Schema errors; aborting catalog build.");
    errors.forEach((e) => console.error(" -", e.file, "\n  ", e.message));
    process.exit(1);
  }

  const cards = items.map(({ data }) => buildPackageCardProps(data));
  const sliced = typeof limit === "number" ? cards.slice(0, limit) : cards;

  const payload = {
    generatedAt: new Date().toISOString(),
    count: sliced.length,
    items: sliced.map((c) => ({
      slug: c.slug,
      name: c.name,
      description: c.description,
      price: c.price,
      features: c.features,
      service: c.service,
      tags: c.tags,
      href: c.href,
      badge: c.badge,
    })),
  };

  await fs.mkdir(path.dirname(out), { recursive: true });
  await fs.writeFile(out, JSON.stringify(payload, null, minify ? 0 : 2), "utf8");
  if (!quiet) console.log(`✔ catalog → ${out} (${payload.count} items)`);
})().catch((err) => {
  console.error("✖ build-catalog-json failed\n", err);
  process.exit(1);
});
```

---

## 3) `scripts/packages/build-unified-search.ts`

**Purpose**
Create a **tiny inverted index** + docs list for fast client/server search across packages.

**Reads**

* Validated packages via `loadAllPackages()`

**Writes**

* `public/generated/packages.search.json` (default)

**CLI**

* `--registry-root=<dir>`
* `--out=<file>` (default: `public/generated/packages.search.json`)
* `--minify` | `--pretty` (default: minify to keep small)
* `--quiet`

**Index design**

* **docs**: `[ { id, slug, title, url } ]`
* **index**: `{ token: [docId, ...] }` with lowercase tokens
* Token sources: `name`, `summary`, `description`, `features`, `tags`, `service`

**Starter template**

```ts
// scripts/packages/build-unified-search.ts
import { loadAllPackages } from "@/packages/lib/registry/loader";
import fs from "node:fs/promises";
import path from "node:path";

function arg(name: string, def?: string) {
  const hit = process.argv.find((a) => a.startsWith(`${name}=`));
  return hit ? hit.split("=").slice(1).join("=") : def;
}
function has(flag: string) { return process.argv.includes(flag); }

function tokenize(s: string): string[] {
  return s
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, " ")
    .split(/\s+/)
    .filter((t) => t.length > 1);
}

(async () => {
  const registryRoot = arg("--registry-root", "src/packages/registry");
  const out = arg("--out", "public/generated/packages.search.json")!;
  const minify = has("--minify") || !has("--pretty"); // default minify
  const quiet = has("--quiet");

  const { items, errors } = await loadAllPackages({ registryRoot });
  if (errors.length) {
    console.error("✖ Schema errors; aborting search build.");
    errors.forEach((e) => console.error(" -", e.file, "\n  ", e.message));
    process.exit(1);
  }

  const docs = items.map(({ data }, i) => ({
    id: i,
    slug: data.slug,
    title: data.name,
    url: `/packages/${data.slug}`,
    tokens: [
      data.name,
      data.summary ?? "",
      data.description ?? "",
      ...(data.features ?? []).map((f) => (typeof f === "string" ? f : f?.label ?? "")),
      ...(data.tags ?? []),
      data.service ?? "",
    ].join(" "),
  }));

  const index: Record<string, number[]> = {};
  for (const d of docs) {
    const seen = new Set<string>();
    for (const tok of tokenize(d.tokens)) {
      if (seen.has(tok)) continue;
      (index[tok] ||= []).push(d.id);
      seen.add(tok);
    }
    delete (d as any).tokens;
  }

  const payload = { generatedAt: new Date().toISOString(), index, docs };
  await fs.mkdir(path.dirname(out), { recursive: true });
  await fs.writeFile(out, JSON.stringify(payload, null, minify ? 0 : 2), "utf8");
  if (!quiet) console.log(`✔ search → ${out} (docs=${docs.length}, terms=${Object.keys(index).length})`);
})().catch((err) => {
  console.error("✖ build-unified-search failed\n", err);
  process.exit(1);
});
```

---

## 4) `scripts/packages/packages-stats.ts`

**Purpose**
Print and/or write JSON **stats**: totals, price coverage, min/avg/max monthly, counts by service.

**Reads**

* Validated packages via `loadAllPackages()`

**Writes**

* Console report
* Optional JSON via `--out`

**CLI**

* `--registry-root=<dir>`
* `--out=<file>` (optional)
* `--minify` | `--pretty` (default: pretty)
* `--quiet`

**Starter template**

```ts
// scripts/packages/packages-stats.ts
import { loadAllPackages } from "@/packages/lib/registry/loader";
import fs from "node:fs/promises";
import path from "node:path";

function arg(name: string, def?: string) {
  const hit = process.argv.find((a) => a.startsWith(`${name}=`));
  return hit ? hit.split("=").slice(1).join("=") : def;
}
function has(flag: string) { return process.argv.includes(flag); }

function round(n: number | undefined) { return n == null ? undefined : Math.round(n); }

(async () => {
  const registryRoot = arg("--registry-root", "src/packages/registry");
  const out = arg("--out"); // optional
  const minify = has("--minify") && !has("--pretty");
  const quiet = has("--quiet");

  const { items, errors } = await loadAllPackages({ registryRoot });
  if (errors.length) {
    console.error("✖ Schema errors; cannot compute stats.");
    errors.forEach((e) => console.error(" -", e.file, "\n  ", e.message));
    process.exit(1);
  }

  const monthlyVals: number[] = [];
  const services: Record<string, number> = {};
  let withMonthly = 0, withSetup = 0;

  for (const { data } of items) {
    const m = data.price?.monthly;
    const o = data.price?.oneTime;
    if (typeof m === "number" && Number.isFinite(m)) { monthlyVals.push(m); withMonthly++; }
    if (typeof o === "number" && Number.isFinite(o)) { withSetup++; }
    const svc = data.service ?? "unknown";
    services[svc] = (services[svc] ?? 0) + 1;
  }

  monthlyVals.sort((a, b) => a - b);
  const avg = monthlyVals.length ? Math.round(monthlyVals.reduce((a, c) => a + c, 0) / monthlyVals.length) : undefined;

  const payload = {
    generatedAt: new Date().toISOString(),
    total: items.length,
    withMonthly,
    withSetup,
    avgMonthly: round(avg),
    minMonthly: round(monthlyVals[0]),
    maxMonthly: round(monthlyVals[monthlyVals.length - 1]),
    services,
  };

  if (!quiet) {
    console.log(`Packages: ${payload.total}`);
    console.log(`With monthly: ${payload.withMonthly} • With setup: ${payload.withSetup}`);
    console.log(
      `Avg monthly: ${payload.avgMonthly ?? "-"} • Min: ${payload.minMonthly ?? "-"} • Max: ${payload.maxMonthly ?? "-"}`
    );
    console.log("By service:");
    Object.keys(payload.services).sort().forEach((k) => console.log(`  ${k}: ${payload.services[k]}`));
  }

  if (out) {
    await fs.mkdir(path.dirname(out), { recursive: true });
    await fs.writeFile(out, JSON.stringify(payload, null, minify ? 0 : 2), "utf8");
    if (!quiet) console.log(`✔ stats → ${out}`);
  }
})().catch((err) => {
  console.error("✖ packages-stats failed\n", err);
  process.exit(1);
});
```

---

## 5) `scripts/packages/mdx-to-registry.ts` (optional)

**Purpose**
Transform MDX frontmatter into runtime **Package** JSON using your authoring schema.

**Reads**

* MDX files (e.g., `content/packages/**/*.mdx`)

**Uses**

* `PackageMarkdownSchema` + `frontmatterToPackage(...)` from `mdx-frontmatter-schema.ts`
* Final validation with `parsePackage` from `package-schema.ts`

**Writes**

* `src/packages/registry/<service>/<slug>/content.generated.json`

**CLI**

* `--src=<glob>` (repeatable)
* `--out=<registry-root>` (default: `src/packages/registry`)
* `--clean` (remove old generated files first)
* `--dry-run`, `--verbose`

**Starter template (skeleton)**

```ts
// scripts/packages/mdx-to-registry.ts
import fs from "node:fs/promises";
import path from "node:path";
import fg from "fast-glob";
import matter from "gray-matter";
import { frontmatterToPackage } from "@/packages/lib/mdx-frontmatter-schema";
import { parsePackage } from "@/packages/lib/package-schema";

function arg(name: string, def?: string) {
  const hit = process.argv.find((a) => a.startsWith(`${name}=`));
  return hit ? hit.split("=").slice(1).join("=") : def;
}
function has(flag: string) { return process.argv.includes(flag); }

(async () => {
  const src = (process.argv.filter((a) => a.startsWith("--src=")).map((a) => a.split("=")[1]));
  const patterns = src.length ? src : ["content/packages/**/*.mdx"];
  const outRoot = arg("--out", "src/packages/registry")!;
  const dryRun = has("--dry-run");
  const verbose = has("--verbose");

  const files = await fg(patterns, { dot: false });
  for (const file of files) {
    const raw = await fs.readFile(file, "utf8");
    const fm = matter(raw).data as Record<string, unknown>;

    // Authoring → runtime
    const partial = frontmatterToPackage(fm);
    const pkg = parsePackage(partial); // SSOT validation

    const serviceDir = String(pkg.service ?? "unknown");
    const slug = String(pkg.slug);
    const dest = path.join(outRoot, serviceDir, slug, "content.generated.json");

    if (verbose) console.log(`→ ${file}  ⇒  ${dest}`);
    if (!dryRun) {
      await fs.mkdir(path.dirname(dest), { recursive: true });
      await fs.writeFile(dest, JSON.stringify(pkg, null, 2), "utf8");
    }
  }
  if (!dryRun) console.log("✔ mdx-to-registry complete");
  else console.log("ℹ dry run — no files written");
})().catch((err) => {
  console.error("✖ mdx-to-registry failed\n", err);
  process.exit(1);
});
```

---

## 6) `scripts/packages/mirror-docs-to-registry.ts` (optional)

**Purpose**
Mirror Markdown/MDX or assets into each package folder so pages can read colocated docs.

**Reads**

* Source docs/asset directory

**Writes**

* Files under `src/packages/registry/<service>/<slug>/docs/*` (or `assets/*`)

**CLI**

* `--from=<dir>` (source)
* `--to=<registry-root>` (default: `src/packages/registry`)
* `--delete-orphans`
* `--dry-run`, `--verbose`

**Starter template (minimal)**

```ts
// scripts/packages/mirror-docs-to-registry.ts
import fs from "node:fs/promises";
import path from "node:path";
import fg from "fast-glob";

function arg(name: string, def?: string) {
  const hit = process.argv.find((a) => a.startsWith(`${name}=`));
  return hit ? hit.split("=").slice(1).join("=") : def;
}
function has(flag: string) { return process.argv.includes(flag); }

(async () => {
  const from = arg("--from", "content/packages/docs")!;
  const toRoot = arg("--to", "src/packages/registry")!;
  const dryRun = has("--dry-run");
  const verbose = has("--verbose");

  const files = await fg([`${from}/**/*`], { onlyFiles: true });
  for (const src of files) {
    // Convention: file path embeds <service>/<slug>/... after the from root
    const rel = path.relative(from, src); // e.g., seo-services/local-seo-starter/readme.mdx
    const dest = path.join(toRoot, rel.replace(/\/([^/]+)\/([^/]+)\//, "/$1/$2/docs/"));
    if (verbose) console.log(`→ ${src}  ⇒  ${dest}`);
    if (!dryRun) {
      await fs.mkdir(path.dirname(dest), { recursive: true });
      await fs.copyFile(src, dest);
    }
  }
  console.log(dryRun ? "ℹ dry run — no files copied" : "✔ mirror-docs complete");
})().catch((err) => {
  console.error("✖ mirror-docs-to-registry failed\n", err);
  process.exit(1);
});
```

---

## 7) `scripts/packages/doctor.ts` (optional shim)

**Purpose**
Single-command “health check”: run all validations with quiet output.

**Script**

```ts
// scripts/packages/doctor.ts
import { execa } from "execa";
await execa("tsx", ["scripts/packages/validate.ts", "--all", "--quiet"], { stdio: "inherit" });
```

---

# How these new scripts fit your pipeline

Update `package.json` (if you haven’t already):

```json
{
  "scripts": {
    "packages:build": "tsx scripts/packages/build.ts",
    "packages:validate": "tsx scripts/packages/validate.ts --all",
    "packages:manifest": "tsx scripts/packages/generate-registry-manifest.ts",
    "packages:catalog": "tsx scripts/packages/build-catalog-json.ts",
    "packages:search": "tsx scripts/packages/build-unified-search.ts",
    "packages:stats": "tsx scripts/packages/packages-stats.ts",
    "packages:mdx": "tsx scripts/packages/mdx-to-registry.ts",
    "packages:mirror-docs": "tsx scripts/packages/mirror-docs-to-registry.ts",
    "packages:doctor": "tsx scripts/packages/doctor.ts"
  }
}
```

And your orchestrator `build.ts` already runs the core six steps in order:

1. `mdx-to-registry.ts` *(optional)*
2. `validate.ts --schema --featured --growth`
3. `generate-registry-manifest.ts`
4. `build-catalog-json.ts`
5. `build-unified-search.ts`
6. `packages-stats.ts`

---

## Guardrails (apply to all scripts)

* **Always** read packages through `src/packages/lib/registry/loader.ts`.
  This guarantees Zod validation and consistent errors.
* **Never** import React or app components in scripts.
  Keep them framework-agnostic for CI stability.
* **Deterministic outputs**: stable sorting, pretty JSON by default (minify for shipped assets like search).
* **Fail if validation fails** when a step produces downstream artifacts.

---

If you want, I can tailor any of the skeletons above to your exact config file shapes, add unit-testable pure helpers, or wire up more advanced search tokenization (e.g., stemming/stopwords).
