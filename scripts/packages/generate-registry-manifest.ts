// scripts/packages/generate-registry-manifest.ts
/**
 * generate-registry-manifest.ts
 * =============================================================================
 * PURPOSE
 * -----------------------------------------------------------------------------
 * Build-time utility that:
 * 1) Ensures each package folder under `src/packages/registry/*-packages/*\/`
 * has a production-ready `index.ts` loader:
 * - Prefers `./content.generated.json` (from your MDX pipeline)
 * - Falls back to `./base.ts` (hand-authored SSOT)
 * The loader validates the chosen source with `PackageSchema`.
 *
 * 2) Generates a static `manifest.ts` that imports every package loader once
 * and exports `REGISTRY` as an array of those validated package objects.
 * Static imports keep Next.js happy (no dynamic `require`, no glob runtime).
 *
 * 3) Generates a tiny data façade at `src/data/packages/index.ts` that exposes:
 * - `BUNDLES`: the list of packages (for page render + SSG)
 * - `getBundleBySlug(slug)`: convenience finder
 * - `ADDONS_BY_ID`: placeholder mapping (keep if you don’t have add-ons yet)
 *
 * USAGE
 * -----------------------------------------------------------------------------
 * # Generate/refresh loaders + manifest + data facade
 * npx tsx scripts/packages/generate-registry-manifest.ts
 *
 * # Options
 * --force     Overwrite existing per-package index.ts files
 * --verbose   Print extra diagnostics
 * --dry-run   Show what would be written without touching the FS
 *
 * EXAMPLE OUTPUT (files this script writes)
 * -----------------------------------------------------------------------------
 * src/packages/registry/lead-generation-packages/lead-routing-distribution/index.ts   <- per-package loader
 * src/packages/registry/manifest.ts                                                  <- static, tree-shakable imports
 * src/data/packages/index.ts                                                         <- data façade for Next pages
 *
 * INTEGRATION WITH YOUR PIPELINE
 * -----------------------------------------------------------------------------
 * Run this after your MDX step, e.g.:
 * 1) npx tsx scripts/packages/mdx-to-registry.ts   # writes content.generated.json files
 * 2) npx tsx scripts/packages/generate-registry-manifest.ts
 *
 * NEXT.JS SSG
 * -----------------------------------------------------------------------------
 * Your `app/packages/[bundles]/page.tsx` calls `generateStaticParams()` that
 * reads `BUNDLES` from `@/data/packages`. Once this script runs, all new
 * packages automatically get included for SSG/ISR without manual wiring.
 */


import fs from "node:fs/promises";
import path from "node:path";
import fg from "fast-glob";

type Cli = { force?: boolean; dry?: boolean; verbose?: boolean };

function parseArgs(argv = process.argv.slice(2)): Cli {
  const cli: Cli = {};
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--force") cli.force = true;
    if (a === "--dry-run" || a === "--dry") cli.dry = true;
    if (a === "--verbose") cli.verbose = true;
  }
  return cli;
}

const ROOT = process.cwd();
const REGISTRY_ROOT = path.resolve(ROOT, "src/packages/registry");
const DATA_FACADE = path.resolve(ROOT, "src/data/packages/index.ts");
const MANIFEST_FILE = path.resolve(REGISTRY_ROOT, "manifest.ts");

/** Find all package directories like: src/packages/registry/*-packages/*/ */
async function findPackageDirs(): Promise<string[]> {
  const pattern = path.posix.join(
    path.relative(ROOT, REGISTRY_ROOT).split(path.sep).join(path.posix.sep),
    "*-packages",
    "*",
  );
  const matches = await fg(pattern, { onlyDirectories: true, dot: false });
  // Return absolute paths
  return matches.map((p) => path.resolve(ROOT, p));
}

/** Small helper: does <file> exist? */
async function exists(file: string) {
  try { await fs.access(file); return true; } catch { return false; }
}

/** Create a safe import variable like: leadgen_lead_routing_distribution */
function makeVarName(serviceDir: string, slugDir: string) {
  const svc = serviceDir.replace(/-packages$/, "");
  return `${svc}_${slugDir}`.replace(/[^a-z0-9_]/gi, "_");
}

/** Write a file only when contents changed (keeps git noise and rebuilds down). */
async function writeIfChanged(file: string, next: string, dry = false) {
  const prev = await (exists(file) ? fs.readFile(file, "utf8") : "");
  if (prev === next) return false;
  if (dry) return true;
  await fs.mkdir(path.dirname(file), { recursive: true });
  await fs.writeFile(file, next, "utf8");
  return true;
}

/** Build per-package `index.ts` loader content for the chosen source. */
function renderPackageIndex(opts: { prefer: "json" | "base"; relJson: string; relBase: string }) {
  const banner =
    `/**\n` +
    ` * AUTO-GENERATED by scripts/packages/generate-registry-manifest.ts\n` +
    ` * Do not edit by hand. Prefer regenerating from MDX or base.ts.\n` +
    ` */\n\n` +
    `/* eslint-disable */\n`;

  if (opts.prefer === "json") {
    return (
      banner +
      `import content from "${opts.relJson}";\n` +
      `import { PackageSchema } from "@/packages/lib/package-schema";\n\n` +
      `const pkg = PackageSchema.parse(content);\n` +
      `export default pkg;\n` +
      `export type PackageRecord = typeof pkg;\n`
    );
  }
  // fallback → base.ts
  return (
    banner +
    `import { base } from "${opts.relBase}";\n` +
    `import { PackageSchema } from "@/packages/lib/package-schema";\n\n` +
    `const pkg = PackageSchema.parse(base);\n` +
    `export default pkg;\n` +
    `export type PackageRecord = typeof pkg;\n`
  );
}

/** Generate the manifest with static imports and REGISTRY array. */
function renderManifest(entries: Array<{ varName: string; importPath: string }>) {
  const header =
    `/**\n` +
    ` * AUTO-GENERATED manifest of all packages.\n` +
    ` * Each item is the validated default export of a per-package loader.\n` +
    ` * Regenerate with: npx tsx scripts/packages/generate-registry-manifest.ts\n` +
    ` */\n\n` +
    `/* eslint-disable */\n`;

  const imports = entries
    .map((e) => `import ${e.varName} from "${e.importPath}";`)
    .join("\n");

  const body =
    `\nexport const REGISTRY = [\n` +
    entries.map((e) => `  ${e.varName},`).join("\n") +
    `\n] as const;\n\n` +
    `export type RegistryItem = (typeof REGISTRY)[number];\n` +
    `export const SLUGS = REGISTRY.map((p) => p.slug);\n`;

  return header + imports + body;
}

/** Generate the data façade consumed by `app/packages/[bundles]/page.tsx`. */
function renderDataFacade() {
  const header =
    `/**\n` +
    ` * AUTO-GENERATED data façade for package pages.\n` +
    ` * Exposes BUNDLES, getBundleBySlug, and ADDONS_BY_ID.\n` +
    ` * This file is intentionally tiny; it only re-exports from the manifest.\n` +
    ` */\n\n` +
    `/* eslint-disable */\n`;

  return (
    header +
    `import { REGISTRY as __REGISTRY } from "@/packages/registry/manifest";\n\n` +
    `// Array of validated package objects (friendly shape used by pages and templates)\n` +
    `export const BUNDLES = [...__REGISTRY];\n\n` +
    `// Convenience: lookup by slug\n` +
    `export function getBundleBySlug(slug: string) {\n` +
    `  return BUNDLES.find((b) => b.slug === slug);\n` +
    `}\n\n` +
    `// Optional add-ons map. If you don't maintain add-ons yet, keep it empty.\n` +
    `export const ADDONS_BY_ID: Record<string, unknown> = {};\n`
  );
}

async function main() {
  const cli = parseArgs();
  const dirs = await findPackageDirs();
  if (cli.verbose) console.log(`Found ${dirs.length} package dir(s).`);

  const manifestEntries: Array<{ varName: string; importPath: string }> = [];

  // 1) Ensure per-package loader index.ts
  for (const absDir of dirs) {
    const serviceDir = path.basename(path.dirname(absDir));     // e.g., "lead-generation-packages"
    const slugDir = path.basename(absDir);                      // e.g., "lead-routing-distribution"
    const varName = makeVarName(serviceDir, slugDir);           // e.g., "lead_generation_lead_routing_distribution"

    const relFromPkg = (p: string) => "./" + path.posix.join(...p.split(path.sep).slice(-1));

    const indexFile = path.resolve(absDir, "index.ts");
    const jsonFile = path.resolve(absDir, "content.generated.json");
    const baseFile = path.resolve(absDir, "base.ts");

    const hasJson = await exists(jsonFile);
    const hasBase = await exists(baseFile);
    const hasIndex = await exists(indexFile);

    if (!hasJson && !hasBase) {
      if (cli.verbose) {
        console.warn(`SKIP: ${absDir} has neither content.generated.json nor base.ts`);
      }
      continue;
    }

    if (!hasIndex || cli.force) {
      const prefer: "json" | "base" = hasJson ? "json" : "base";
      const contents = renderPackageIndex({
        prefer,
        relJson: relFromPkg("content.generated.json"),
        relBase: relFromPkg("base.ts"),
      });

      const changed = await writeIfChanged(indexFile, contents, !!cli.dry);
      if (cli.verbose) {
        console.log(`${changed ? (cli.dry ? "[DRY] would write" : "wrote") : "kept"}: ${path.relative(ROOT, indexFile)} (${prefer})`);
      }
    } else if (cli.verbose) {
      console.log(`kept: ${path.relative(ROOT, indexFile)}`);
    }

    // manifest import path should be alias-based for Next/TS friendliness
    const aliased = "@/packages/registry/" +
      path.relative(REGISTRY_ROOT, path.resolve(absDir, "index")).split(path.sep).join("/");

    manifestEntries.push({ varName, importPath: aliased });
  }

  // Sort by import path for stable diffs
  manifestEntries.sort((a, b) => a.importPath.localeCompare(b.importPath));

  // 2) Write manifest.ts
  const manifestSrc = renderManifest(manifestEntries);
  const manifestChanged = await writeIfChanged(MANIFEST_FILE, manifestSrc, !!cli.dry);
  if (cli.verbose) {
    console.log(`${manifestChanged ? (cli.dry ? "[DRY] would write" : "wrote") : "kept"}: ${path.relative(ROOT, MANIFEST_FILE)}`);
  }

  // 3) Write data façade
  const dataSrc = renderDataFacade();
  const dataChanged = await writeIfChanged(DATA_FACADE, dataSrc, !!cli.dry);
  if (cli.verbose) {
    console.log(`${dataChanged ? (cli.dry ? "[DRY] would write" : "wrote") : "kept"}: ${path.relative(ROOT, DATA_FACADE)}`);
  }

  if (!manifestEntries.length) {
    console.warn("No package loaders were discovered. Did you add any under src/packages/registry/*-packages/*/?");
  } else {
    console.log(`✅ Registry ready with ${manifestEntries.length} package(s).`);
  }
}

main().catch((err) => {
  console.error("❌ generate-registry-manifest failed:");
  console.error(err?.stack || err?.message || err);
  process.exit(1);
});
