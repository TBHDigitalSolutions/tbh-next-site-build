// src/packages/lib/package-schema.ts
/**
 * Package Content Schema (Zod) — Single Source of Truth (SSOT)
 * =============================================================================
 * 
 * VERSION: 2.0.0
 * 
 * PURPOSE
 * -----------------------------------------------------------------------------
 * This is the canonical validator for all package data in the application.
 * It serves as the Single Source of Truth (SSOT) for:
 * 
 * - Runtime validation during the build pipeline
 * - TypeScript type generation for the entire codebase
 * - JSON Schema generation (via build-json-schema.ts)
 * - Author-lint pre-build validation
 * - Registry loaders and UI components
 * 
 * CONSUMERS
 * -----------------------------------------------------------------------------
 * - Build Pipeline: scripts/packages/build-package-data.ts
 * - Author Lint: scripts/author-lint.ts (pre-build validation)
 * - JSON Schema Generator: scripts/packages/build-json-schema.ts
 * - Registry Loaders: src/packages/registry/*\/base.ts
 * - UI Mappers: src/packages/lib/mappers/*
 * - UI Components: Cards, detail pages, tables
 * 
 * DATA STRUCTURE
 * -----------------------------------------------------------------------------
 * The schema enforces a nested, snake_case structure that mirrors the
 * JSON files generated by the build pipeline:
 * 
 * ```json
 * {
 *   "meta": { id, slug, service, name, tier, badges, tags },
 *   "hero": { summary, description, image, ctas, seo },
 *   "narrative": { overview_html, purpose_html, notes_html, faq_html },
 *   "why_you_need_this": { icp, pain_points, outcomes },
 *   "what_you_get": { features, includes, includes_table, deliverables },
 *   "details_and_trust": { pricing, price_band, timeline, requirements, ethics, limits, notes },
 *   "next_step": { faqs, cross_sell, related_slugs, add_on_recommendations },
 *   "copy": { phase1, phase2, phase3, phase4, phase5 },
 *   "extras": { timeline_blocks, ... }
 * }
 * ```
 * 
 * AUTHORING WORKFLOW
 * -----------------------------------------------------------------------------
 * 1. Authors edit: content/packages/catalog/<service>/<slug>/public.mdx
 * 2. Build parses: MDX frontmatter (any case) + body sections
 * 3. Build normalizes: camelCase → snake_case, arrays → strings (notes)
 * 4. Build validates: THIS SCHEMA ensures data integrity
 * 5. Build writes: src/data/packages/__generated__/packages/<slug>.json
 * 6. UI consumes: Type-safe imports via registry loaders
 * 
 * KEY FEATURES
 * -----------------------------------------------------------------------------
 * 
 * 1. SERVICE NORMALIZATION (Author-Friendly)
 *    Accepts various formats and normalizes to canonical values:
 *    - Accepts: "seo services", "lead-generation", "content production"
 *    - Outputs: "seo", "leadgen", "content", "marketing", "video", "webdev"
 * 
 * 2. PRICING VALIDATION (SSOT)
 *    - Enforces: at least one of one_time or monthly must be > 0
 *    - PRC001 Rule: If pricing exists, price_band.tagline is REQUIRED
 *    - Prevents: invented copy, ensures brand consistency
 * 
 * 3. INCLUDES VALIDATION (UI Consistency)
 *    - Enforces: exactly ONE of includes (groups) OR includes_table (table)
 *    - Prevents: both present (layout conflicts), neither present (broken render)
 * 
 * 4. DRIFT PROTECTION (SSOT Enforcement)
 *    - Bans display-only fields: startingAt, priceTeaser, packagePrice, etc.
 *    - These MUST be derived at render time from the pricing SSOT
 * 
 * 5. TYPE SAFETY (Compile-Time Checking)
 *    - All types are inferred from Zod schemas
 *    - Changes propagate automatically throughout the codebase
 *    - Prevents runtime type errors
 * 
 * VALIDATION RULES (CI-ENFORCED)
 * -----------------------------------------------------------------------------
 * 
 * PRC001: Pricing Requires Tagline
 * - If one_time > 0 OR monthly > 0, then price_band.tagline is REQUIRED
 * - Rationale: Taglines are marketing-critical, must be intentionally authored
 * - Checked by: author-lint.ts (pre-build) + this schema (build-time)
 * 
 * INC001: Includes XOR Table
 * - Must have EXACTLY ONE of includes OR includes_table
 * - Rationale: UI components expect one format for consistent rendering
 * - Checked by: author-lint.ts (pre-build)
 * 
 * CTA001: No Duplicate CTAs
 * - hero.ctas and next_step.ctas must have distinct labels
 * - Rationale: Prevents redundant buttons that confuse users
 * - Checked by: author-lint.ts (pre-build)
 * 
 * DRIFT001: No Display Fields
 * - Ban fields like startingAt, priceTeaser that derive from SSOT
 * - Rationale: Ensures price is the single source of truth
 * - Checked by: this schema (build-time)
 * 
 * USAGE EXAMPLES
 * -----------------------------------------------------------------------------
 * 
 * ```typescript
 * // Strict validation (throws on error) - use in build scripts
 * import { parsePackage, type Package } from './package-schema';
 * const pkg: Package = parsePackage(jsonData);
 * 
 * // Safe validation (returns result) - use in guards/tests
 * import { safeParsePackage } from './package-schema';
 * const result = safeParsePackage(jsonData);
 * if (result.success) {
 *   const pkg: Package = result.data;
 *   // Use pkg safely
 * } else {
 *   console.error("Validation failed:", result.error);
 * }
 * 
 * // Type-only import (no validation)
 * import type { Money, PriceBand, Package } from './package-schema';
 * ```
 * 
 * MAINTENANCE
 * -----------------------------------------------------------------------------
 * 
 * When modifying this schema:
 * 1. Update version number in header comments
 * 2. Run: npm run schema:build (regenerates JSON Schema)
 * 3. Run: npm run data:build (regenerates all package JSON)
 * 4. Run: npm run lint:author (validates existing packages)
 * 5. Update: docs/packages/authoring-rules.md if rules changed
 * 
 * Schema changes automatically propagate to:
 * - TypeScript types (exported at bottom of this file)
 * - JSON Schema (via build-json-schema.ts)
 * - Build validation (via parsePackage function)
 * - Author-lint rules (should mirror schema rules)
 * 
 * RELATED FILES
 * -----------------------------------------------------------------------------
 * @see scripts/author-lint.ts - Pre-build content validation
 * @see scripts/packages/build-json-schema.ts - JSON Schema generator
 * @see scripts/packages/build-package-data.ts - Main build script
 * @see docs/packages/authoring-rules.md - Authoring documentation
 * @see src/packages/lib/mappers/* - Schema → UI prop transformers
 * 
 * @version 2.0.0
 * @since 1.0.0
 */

import { z } from "zod";

// =============================================================================
// Constants & Configuration
// =============================================================================

/**
 * Canonical service categories supported by the application.
 * 
 * These are the normalized output values after alias resolution.
 * All UI logic, routing, and categorization uses these values.
 * 
 * @constant
 * @type {ReadonlyArray<string>}
 */
export const SERVICES = [
  "content",    // Content production, copywriting, editorial
  "leadgen",    // Lead generation, lead routing, distribution
  "marketing",  // Marketing strategy, campaigns, automation
  "seo",        // Search engine optimization, SEO services
  "video",      // Video production, motion graphics, animation
  "webdev"      // Web development, web design, web services
] as const;

/**
 * Service type - one of the canonical service categories
 * 
 * @typedef {typeof SERVICES[number]} Service
 */
export type Service = (typeof SERVICES)[number];

// =============================================================================
// Utility Schemas & Helpers
// =============================================================================

/**
 * Trimmed string schema - automatically removes leading/trailing whitespace.
 * 
 * Use this for all user-facing text fields to ensure clean data.
 * 
 * @constant
 */
const Str = z.string().trim();

/**
 * HTML content string schema - for compiled MDX sections.
 * 
 * These fields contain rendered HTML from markdown body sections.
 * 
 * @constant
 */
const Html = z.string().trim();

/**
 * Kebab-case ID pattern: service-name-variant
 * 
 * Format: lowercase letters, digits, hyphens only
 * Must start with letter, must contain at least one hyphen
 * 
 * @example "seo-featured-snippet"
 * @example "video-explainer-starter"
 * 
 * @constant
 */
const KEBAB_ID = /^[a-z]+-[a-z0-9-]+$/;

/**
 * Kebab-case slug pattern: simple-slug-name
 * 
 * Format: lowercase letters, digits, hyphens only
 * Must start with letter
 * 
 * @example "featured-snippet"
 * @example "explainer-starter"
 * 
 * @constant
 */
const KEBAB_SLUG = /^[a-z][a-z0-9-]*$/;

/**
 * Primitive value types allowed in includes tables.
 * 
 * Tables can contain simple values: strings, booleans, numbers, or null.
 * Complex objects are not supported for simplicity.
 * 
 * @constant
 */
const Primitive = z.union([
  z.string(),
  z.boolean(),
  z.number(),
  z.null()
]);

// =============================================================================
// Service Normalization
// =============================================================================

/**
 * Normalizes various service name formats to canonical values.
 * 
 * This function provides author-friendly flexibility while ensuring
 * consistent canonical values throughout the application.
 * 
 * NORMALIZATION RULES:
 * - Converts to lowercase
 * - Unifies separators (underscores, spaces → hyphens)
 * - Removes "service(s)" suffix
 * - Maps aliases to canonical names
 * 
 * SUPPORTED ALIASES:
 * - content: "content", "content-production", "content production"
 * - leadgen: "leadgen", "lead-generation", "lead generation"
 * - marketing: "marketing", "marketing-services", "marketing services"
 * - seo: "seo", "seo services", "search-engine-optimization"
 * - video: "video", "video-production", "video production"
 * - webdev: "webdev", "web-development", "web development"
 * 
 * @param input - Raw service value from MDX frontmatter (any format)
 * @returns Normalized canonical service name
 * @throws {Error} If service cannot be recognized
 * 
 * @example
 * normalizeService("SEO Services") // returns "seo"
 * normalizeService("lead_generation") // returns "leadgen"
 * normalizeService("content production") // returns "content"
 * normalizeService("invalid") // throws Error
 */
function normalizeService(input: unknown): Service {
  const raw = String(input ?? "").toLowerCase().trim();
  
  // Unify separators: underscores and spaces → hyphens
  const s = raw
    .replace(/_/g, "-")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-"); // collapse multiple hyphens
  
  // Remove common suffixes that authors might add
  const base = s.replace(/-?services?$/i, "");
  
  // Helper function to check if string contains keyword
  const has = (keyword: string) => s.includes(keyword);
  
  // Map to canonical service (order matters - check specific first)
  if (base === "content" || has("content-production")) {
    return "content";
  }
  
  if (
    base === "leadgen" ||
    base === "lead-generation" ||
    has("lead-generation") ||
    has("leadgen")
  ) {
    return "leadgen";
  }
  
  if (base === "marketing" || has("marketing")) {
    return "marketing";
  }
  
  if (base === "seo" || has("search-engine-optimization") || has("seo")) {
    return "seo";
  }
  
  if (base === "video" || base === "video-production" || has("video-production")) {
    return "video";
  }
  
  if (
    base === "webdev" ||
    base === "web-development" ||
    has("web-development") ||
    has("webdev")
  ) {
    return "webdev";
  }
  
  // If we get here, the service is unrecognized
  throw new Error(
    `Unrecognized service: "${raw}". ` +
    `Must be one of: ${SERVICES.join(", ")} ` +
    `or their aliases (e.g., "seo services", "lead-generation", "content production"). ` +
    `See docs/packages/authoring-rules.md for details.`
  );
}

/**
 * Zod schema that accepts any input, normalizes it, and validates the output.
 * 
 * This schema is used in MetaSchema to ensure service values are always canonical.
 * 
 * @constant
 */
const ServiceNormalizedSchema = z
  .any()
  .transform((v) => normalizeService(v))
  .refine(
    (v): v is Service => (SERVICES as readonly string[]).includes(v as string),
    { message: "Service must normalize to a valid canonical value" }
  );

// =============================================================================
// Pricing Schemas (SSOT)
// =============================================================================

/**
 * Money schema - represents package pricing (Single Source of Truth).
 * 
 * RULES:
 * - At least one of one_time or monthly must be > 0
 * - Currency is always USD (hard-coded for current scope)
 * - Values can be null/undefined for optional pricing models
 * 
 * IMPORTANT: This is the SSOT for all pricing data.
 * Display labels (e.g., "Starting at $2,500") MUST be derived at render time.
 * Never store computed/display values in the data layer.
 * 
 * @constant
 * @property {number|null|undefined} one_time - One-time project price in USD
 * @property {number|null|undefined} monthly - Monthly recurring price in USD
 * @property {"USD"} currency - Currency code (currently USD only)
 * 
 * @example
 * // One-time only
 * { one_time: 2500, monthly: null, currency: "USD" }
 * 
 * // Monthly only
 * { one_time: null, monthly: 500, currency: "USD" }
 * 
 * // Hybrid (both)
 * { one_time: 1000, monthly: 250, currency: "USD" }
 */
export const MoneySchema = z
  .object({
    one_time: z.number().min(0).nullable().optional(),
    monthly: z.number().min(0).nullable().optional(),
    currency: z.literal("USD"),
  })
  .refine(
    (p) =>
      (typeof p.one_time === "number" && p.one_time > 0) ||
      (typeof p.monthly === "number" && p.monthly > 0),
    {
      message:
        "At least one of one_time or monthly must be greater than 0. " +
        "Packages must have pricing to be valid.",
    }
  );

/**
 * Price band copy schema - detail-page-only marketing content.
 * 
 * CRITICAL: This content is NEVER included in card props.
 * Cards show price figures only. Price band copy appears only on detail pages.
 * 
 * FIELDS:
 * - tagline: Marketing message about the price (REQUIRED when pricing exists - PRC001)
 * - base_note: Whether price is "proposal" (estimate) or "final" (fixed)
 * - fine_print: Additional pricing notes, caveats, disclaimers
 * 
 * PRC001 ENFORCEMENT:
 * The tagline field is technically optional in this schema, but the
 * PackageSchema superRefine enforces that it MUST be present when pricing exists.
 * This prevents invented copy and ensures brand consistency.
 * 
 * @constant
 * @property {string|undefined} tagline - Marketing tagline for pricing (required if priced)
 * @property {"proposal"|"final"|undefined} base_note - Price certainty level
 * @property {string|undefined} fine_print - Additional pricing details
 * 
 * @example
 * {
 *   tagline: "Fixed-scope starter package",
 *   base_note: "proposal",
 *   fine_print: "Studio booking not included. Travel fees may apply."
 * }
 */
export const PriceBandSchema = z.object({
  tagline: Str.optional(),
  base_note: z.enum(["proposal", "final"]).optional(),
  fine_print: Str.optional(),
});

// =============================================================================
// Content Schemas
// =============================================================================

/**
 * FAQ schema - supports both short and long question/answer formats.
 * 
 * AUTHORS CAN USE EITHER:
 * - Short format: { q: "...", a: "..." }
 * - Long format: { question: "...", answer: "..." }
 * 
 * At least one valid format must be provided.
 * The id field is optional and used for anchor links.
 * 
 * @constant
 * @property {string|number|undefined} id - Optional identifier for anchor links
 * @property {string|undefined} q - Short question (use with 'a')
 * @property {string|undefined} a - Short answer (use with 'q')
 * @property {string|undefined} question - Long question (use with 'answer')
 * @property {string|undefined} answer - Long answer (use with 'question')
 * 
 * @example
 * // Short format
 * { id: 1, q: "How long?", a: "2-3 weeks" }
 * 
 * // Long format
 * { id: "timeline", question: "What is the timeline?", answer: "The project typically takes 2-3 weeks..." }
 */
export const FaqSchema = z
  .object({
    id: z.union([Str, z.number()]).optional(),
    q: Str.optional(),
    a: Str.optional(),
    question: Str.optional(),
    answer: Str.optional(),
  })
  .refine(
    (x) => (!!x.q && !!x.a) || (!!x.question && !!x.answer),
    {
      message:
        "FAQ must contain either (q + a) or (question + answer). " +
        "Provide at least one valid Q&A format.",
    }
  );

/**
 * Include item schema - a single deliverable in an includes group.
 * 
 * FORMATS SUPPORTED:
 * - Simple string: "Script (up to 90 seconds)"
 * - Object with note: { label: "Script", note: "(up to 90 seconds)" }
 * 
 * The object format allows for structured display with separate label/note.
 * 
 * @constant
 * 
 * @example
 * // Simple string
 * "2D Animation"
 * 
 * // Object with note
 * { label: "Script", note: "(up to 90 seconds)" }
 */
export const IncludeItemSchema = z.union([
  Str.min(1),
  z.object({
    label: Str.min(1),
    note: Str.optional(),
  }),
]);

/**
 * Include group schema - a named collection of deliverables.
 * 
 * Groups organize deliverables into logical categories.
 * Used when the "includes" format is chosen (vs. includesTable).
 * 
 * @constant
 * @property {string} title - Group heading (e.g., "Core Deliverables")
 * @property {Array<IncludeItem>} items - List of deliverables (min 1)
 * 
 * @example
 * {
 *   title: "Core Deliverables",
 *   items: [
 *     "Script (up to 90 seconds)",
 *     { label: "Storyboard", note: "(8-12 frames)" },
 *     "2D Animation"
 *   ]
 * }
 */
export const IncludeGroupSchema = z.object({
  title: Str.min(1),
  items: z.array(IncludeItemSchema).min(1),
});

/**
 * Includes table schema - structured comparison table for deliverables.
 * 
 * Use this format when you need to compare deliverables across dimensions
 * (e.g., "Included", "Add-on", "Premium tier").
 * 
 * FORMATS SUPPORTED:
 * 
 * Simple columns: ["Item", "Included", "Add-on"]
 * Object columns: [{ id: "item", label: "Item" }, ...]
 * 
 * Simple rows: [["Script", "Yes", "No"], ["Voiceover", "No", "Yes"]]
 * Object rows: [{ id: "script", values: { item: "Script", included: "Yes" } }]
 * 
 * WHEN TO USE:
 * - Comparing multiple tiers or options
 * - Showing included vs. add-on items
 * - Complex deliverable matrices
 * 
 * @constant
 * @property {string|undefined} caption - Optional table caption
 * @property {Array<string|object>} columns - Column headers (min 1)
 * @property {Array<Array|object>} rows - Table rows
 * 
 * @example
 * {
 *   caption: "What's Included",
 *   columns: ["Item", "Included", "Add-on"],
 *   rows: [
 *     ["Script", "Yes", "No"],
 *     ["Voiceover", "No", "Yes ($500)"],
 *     ["Music", "Yes", "Yes (Custom)"]
 *   ]
 * }
 */
export const IncludesTableSchema = z.object({
  caption: Str.optional(),
  columns: z
    .array(
      z.union([
        Str,
        z.object({
          id: Str.optional(),
          label: Str.min(1),
        }),
      ])
    )
    .min(1),
  rows: z.array(
    z.union([
      z.array(Primitive),
      z.object({
        id: Str.optional(),
        label: Str.optional(),
        values: z.record(Primitive),
      }),
    ])
  ),
});

// =============================================================================
// Phase Copy Overrides
// =============================================================================

/**
 * Copy overrides schema for detail page phases (1-5).
 * 
 * Allows authors to customize section titles and taglines per package.
 * All fields are optional - defaults from the template are used if not provided.
 * 
 * PHASE STRUCTURE:
 * - Phase 1: Hero (above the fold)
 * - Phase 2: Why You Need This (pain points, outcomes)
 * - Phase 3: What You Get (features, includes, deliverables) - HAS EXTRA FIELDS
 * - Phase 4: Details & Trust (timeline, requirements, ethics)
 * - Phase 5: Next Steps (FAQs, related packages)
 * 
 * PHASE 3 SPECIAL FIELDS:
 * Phase 3 has additional fields for customizing the "What You Get" section:
 * - includes_title: Custom title for includes section
 * - includes_subtitle: Custom subtitle for includes section
 * - highlights_title: Custom title for highlights/features
 * - highlights_tagline: Custom tagline for highlights/features
 * 
 * @constant
 * 
 * @example
 * {
 *   phase1: { title: "Custom Hero Title", tagline: "Custom tagline" },
 *   phase3: {
 *     title: "What's Included",
 *     includes_title: "Core Deliverables",
 *     highlights_title: "Key Features"
 *   }
 * }
 */
export const PhaseCopySchema = z.object({
  phase1: z
    .object({
      title: Str.optional(),
      tagline: Str.optional(),
    })
    .optional(),
  phase2: z
    .object({
      title: Str.optional(),
      tagline: Str.optional(),
    })
    .optional(),
  phase3: z
    .object({
      title: Str.optional(),
      tagline: Str.optional(),
      includes_title: Str.optional(),
      includes_subtitle: Str.optional(),
      highlights_title: Str.optional(),
      highlights_tagline: Str.optional(),
    })
    .optional(),
  phase4: z
    .object({
      title: Str.optional(),
      tagline: Str.optional(),
    })
    .optional(),
  phase5: z
    .object({
      title: Str.optional(),
      tagline: Str.optional(),
    })
    .optional(),
});

// =============================================================================
// Branch Schemas (Main Data Structure)
// =============================================================================

/**
 * Meta schema - package identity and categorization.
 * 
 * This is the core identification data for every package.
 * 
 * REQUIRED FIELDS:
 * - id: Full kebab-case identifier (service-name-variant)
 * - slug: Short kebab-case slug (name-variant)
 * - service: Canonical service category (normalized from aliases)
 * - name: Display name for the package
 * 
 * OPTIONAL FIELDS:
 * - subservice: Secondary categorization
 * - category: Tertiary categorization
 * - tier: Package tier (starter, pro, enterprise, etc.)
 * - badges: Visual badges (new, popular, recommended, etc.)
 * - tags: Searchable tags for filtering
 * 
 * @constant
 * 
 * @example
 * {
 *   id: "seo-featured-snippet",
 *   slug: "featured-snippet",
 *   service: "seo",
 *   name: "Featured Snippet Optimization",
 *   tier: "starter",
 *   badges: ["popular", "quick-start"],
 *   tags: ["seo", "search", "snippets", "optimization"]
 * }
 */
export const MetaSchema = z.object({
  id: Str.regex(KEBAB_ID, "meta.id must be kebab-case (e.g., seo-featured-snippet)"),
  slug: Str.regex(KEBAB_SLUG, "meta.slug must be kebab-case (e.g., featured-snippet)"),
  service: ServiceNormalizedSchema, // Accepts aliases, outputs canonical
  subservice: Str.optional(),
  category: Str.optional(),
  name: Str.min(1, "Package name is required and cannot be empty"),
  tier: Str.optional(),
  badges: z.array(Str).optional(),
  tags: z.array(Str).optional(),
});

/**
 * Hero schema - above-the-fold content for cards and detail pages.
 * 
 * This content appears prominently on both cards (grid view) and detail pages.
 * 
 * REQUIRED:
 * - summary: Short, compelling summary (1-2 sentences)
 * 
 * OPTIONAL:
 * - description: Longer description for detail pages
 * - image: Hero image with src and optional alt text
 * - ctas: Call-to-action links (details, book_a_call, request_proposal)
 * - seo: SEO overrides for title and meta description
 * 
 * CTA URLS:
 * All CTA URLs are validated as proper URLs.
 * They can be absolute (https://...) or relative (/contact).
 * 
 * @constant
 * 
 * @example
 * {
 *   summary: "Launch a simple explainer video in 2-3 weeks.",
 *   description: "Perfect for startups and small businesses...",
 *   image: {
 *     src: "/assets/explainer-video.png",
 *     alt: "Explainer video starter package"
 *   },
 *   ctas: {
 *     request_proposal: "/contact",
 *     book_a_call: "https://calendly.com/..."
 *   },
 *   seo: {
 *     title: "Explainer Video Starter | Your Company",
 *     description: "Professional explainer videos..."
 *   }
 * }
 */
export const HeroSchema = z.object({
  summary: Str.min(1, "Hero summary is required"),
  description: Str.optional(),
  image: z
    .object({
      src: Str.min(1),
      alt: Str.optional(), // Alt text optional but strongly recommended for accessibility
    })
    .optional(),
  ctas: z
    .object({
      details: z.string().url().optional(),
      book_a_call: z.string().url().optional(),
      request_proposal: z.string().url().optional(),
    })
    .optional(),
  seo: z
    .object({
      title: Str.optional(),
      description: Str.optional(),
    })
    .optional(),
});

/**
 * Narrative schema - compiled HTML from MDX body sections.
 * 
 * These fields are populated automatically by the build pipeline from
 * level-2 headings (##) in the MDX body:
 * 
 * - ## Overview → overview_html
 * - ## Purpose → purpose_html
 * - ## Notes → notes_html
 * - ## FAQ → faq_html
 * 
 * AUTHORS: Write these sections in markdown in the body of public.mdx.
 * BUILD: The pipeline extracts and compiles them to HTML automatically.
 * 
 * @constant
 * 
 * @example
 * // In public.mdx body:
 * // ## Purpose
 * // This package helps you...
 * //
 * // Results in:
 * {
 *   purpose_html: "<p>This package helps you...</p>"
 * }
 */
export const NarrativeSchema = z
  .object({
    overview_html: Html.optional(),
    purpose_html: Html.optional(),
    notes_html: Html.optional(),
    faq_html: Html.optional(),
  })
  .optional();

/**
 * Why You Need This schema - pain points and expected outcomes.
 * 
 * This section helps prospects understand if the package is right for them.
 * 
 * FIELDS:
 * - icp: Ideal Customer Profile (who this is for)
 * - pain_points: List of problems this package solves
 * - outcomes: Expected results/benefits (minimum 3 if provided)
 * 
 * OUTCOMES MINIMUM:
 * If outcomes are provided, at least 3 are required for substance.
 * This ensures meaningful
 * value communication to prospects.
 * 
 * @constant
 * @property {string|undefined} icp - Ideal Customer Profile description
 * @property {Array<string>|undefined} pain_points - Problems this package solves
 * @property {Array<string>|undefined} outcomes - Expected results (min 3 if present)
 * 
 * @example
 * {
 *   icp: "B2B SaaS companies looking to improve organic search visibility",
 *   pain_points: [
 *     "Low organic traffic from target keywords",
 *     "Competitors dominating featured snippets",
 *     "Lack of structured data optimization"
 *   ],
 *   outcomes: [
 *     "Rank in position zero for target keywords",
 *     "Increase click-through rates by 20-30%",
 *     "Establish thought leadership in search results"
 *   ]
 * }
 */
export const WhySchema = z
  .object({
    icp: Str.optional(),
    pain_points: z.array(Str).optional(),
    outcomes: z
      .array(Str)
      .min(3, "Outcomes should have at least 3 items for meaningful value communication")
      .optional(),
  })
  .optional();

/**
 * What You Get schema - features and deliverables.
 * 
 * CRITICAL VALIDATION (INC001):
 * Must have EXACTLY ONE of:
 * - includes (groups of deliverables), OR
 * - includes_table (comparison table)
 * 
 * Not both, not neither. This ensures consistent UI rendering.
 * 
 * FIELDS:
 * - features: High-level feature highlights (used for cards)
 * - includes: Grouped deliverables (list format)
 * - includes_table: Deliverables comparison table
 * - deliverables: Additional flat list of deliverables
 * 
 * FEATURES:
 * Can be simple strings or objects with label + optional icon.
 * Used for "highlights" section on cards and detail pages.
 * 
 * @constant
 * 
 * @example
 * // Using includes (groups)
 * {
 *   features: [
 *     "Professional script writing",
 *     "2D animation",
 *     { label: "Voiceover", icon: "microphone" }
 *   ],
 *   includes: [
 *     {
 *       title: "Core Deliverables",
 *       items: ["Script", "Storyboard", "Animation"]
 *     }
 *   ]
 * }
 * 
 * // Using includes_table (comparison)
 * {
 *   features: ["Comparison of tiers"],
 *   includes_table: {
 *     columns: ["Item", "Starter", "Pro"],
 *     rows: [
 *       ["Script", "Yes", "Yes"],
 *       ["Voiceover", "No", "Yes"]
 *     ]
 *   }
 * }
 */
export const WhatSchema = z
  .object({
    features: z
      .array(
        z.union([
          Str,
          z.object({
            label: Str,
            icon: Str.optional(),
          }),
        ])
      )
      .optional(),
    includes: z.array(IncludeGroupSchema).optional(),
    includes_table: IncludesTableSchema.optional(),
    deliverables: z.array(Str).optional(),
  })
  .refine(
    (v) => !!(v?.includes?.length || v?.includes_table),
    {
      message:
        "Provide either what_you_get.includes (groups) OR what_you_get.includes_table (table). " +
        "Not both, not neither. This ensures consistent UI rendering.",
    }
  )
  .optional();

/**
 * Details and Trust schema - pricing, timeline, requirements, constraints.
 * 
 * This is where the pricing SSOT lives, along with operational details.
 * 
 * REQUIRED:
 * - pricing: Money object (SSOT for all pricing data)
 * 
 * OPTIONAL:
 * - price_band: Detail-page-only pricing copy (tagline, base_note, fine_print)
 * - timeline: Project phases (setup, launch, ongoing)
 * - requirements: What client must provide
 * - ethics: Ethical considerations or limitations
 * - limits: Scope limitations
 * - caveats: Important caveats or disclaimers
 * - notes: Additional notes (single string, arrays normalized during build)
 * 
 * PRICE_BAND vs CARDS:
 * price_band content NEVER appears on cards - only on detail pages.
 * Cards show price figures only, derived at render time from pricing SSOT.
 * 
 * NOTES NORMALIZATION:
 * Authors can provide notes as an array in MDX, but the build pipeline
 * normalizes it to a single string (joined with " • ") before validation.
 * 
 * @constant
 * 
 * @example
 * {
 *   pricing: {
 *     one_time: 2500,
 *     monthly: null,
 *     currency: "USD"
 *   },
 *   price_band: {
 *     tagline: "Fixed-scope starter package",
 *     base_note: "proposal",
 *     fine_print: "Studio booking not included. Travel fees may apply."
 *   },
 *   timeline: {
 *     setup: "1 week",
 *     launch: "2-3 weeks",
 *     ongoing: "Optional retainer available"
 *   },
 *   requirements: [
 *     "Product information and key messaging",
 *     "Brand assets (logo, colors, fonts)",
 *     "Feedback within 48 hours"
 *   ],
 *   ethics: [
 *     "We do not work with tobacco or gambling industries",
 *     "All content must be factually accurate"
 *   ],
 *   limits: [
 *     "One revision round included",
 *     "Up to 90 seconds video length"
 *   ],
 *   notes: "Additional services available as add-ons"
 * }
 */
export const DetailsSchema = z.object({
  pricing: MoneySchema,
  price_band: PriceBandSchema.optional(),
  timeline: z
    .object({
      setup: Str.optional(),
      launch: Str.optional(),
      ongoing: Str.optional(),
    })
    .optional(),
  requirements: z.array(Str).optional(),
  ethics: z.array(Str).optional(),
  limits: z.array(Str).optional(),
  caveats: z.array(Str).optional(),
  notes: Str.optional(), // Single string (arrays normalized during build)
});

/**
 * Next Step schema - FAQs, cross-sells, related packages.
 * 
 * This section appears at the bottom of detail pages to guide next actions.
 * 
 * FIELDS:
 * - faqs: Frequently asked questions (uses FaqSchema)
 * - cross_sell: Related packages and add-ons
 * - related_slugs: Package slugs for "Related Packages" section
 * - add_on_recommendations: Suggested add-ons by slug
 * 
 * CROSS_SELL vs RECOMMENDATIONS:
 * - cross_sell.related: General related packages
 * - cross_sell.add_ons: Add-ons that enhance this package
 * - related_slugs: Simpler slug-only format (preferred)
 * - add_on_recommendations: Simpler slug-only format (preferred)
 * 
 * @constant
 * 
 * @example
 * {
 *   faqs: [
 *     {
 *       q: "How long does it take?",
 *       a: "Typically 2-3 weeks from kickoff to delivery."
 *     },
 *     {
 *       question: "What if I need revisions?",
 *       answer: "One revision round is included. Additional revisions are $500 each."
 *     }
 *   ],
 *   related_slugs: [
 *     "explainer-video-pro",
 *     "motion-graphics-pack"
 *   ],
 *   add_on_recommendations: [
 *     "professional-voiceover",
 *     "custom-music"
 *   ]
 * }
 */
export const NextStepSchema = z
  .object({
    faqs: z.array(FaqSchema).optional(),
    cross_sell: z
      .object({
        related: z.array(Str).optional(),
        add_ons: z.array(Str).optional(),
      })
      .optional(),
    related_slugs: z.array(Str).optional(),
    add_on_recommendations: z.array(Str).optional(),
  })
  .optional();

// =============================================================================
// Root Package Schema
// =============================================================================

/**
 * Complete package data schema with all validation rules.
 * 
 * This is the main export that validates entire package records.
 * It combines all branch schemas and adds cross-field validation via superRefine.
 * 
 * STRUCTURE:
 * - meta: Identity and categorization (REQUIRED)
 * - hero: Above-the-fold content (REQUIRED)
 * - narrative: Compiled MDX sections (optional)
 * - why_you_need_this: Pain points and outcomes (optional)
 * - what_you_get: Features and deliverables (optional)
 * - details_and_trust: Pricing and operational details (REQUIRED)
 * - next_step: FAQs and related packages (optional)
 * - copy: Phase-specific copy overrides (optional)
 * - extras: Extension point for custom data (optional)
 * 
 * CROSS-FIELD VALIDATIONS (superRefine):
 * 
 * 1. PRC001: Pricing Requires Tagline
 *    If pricing exists (one_time > 0 OR monthly > 0),
 *    then price_band.tagline MUST be present and non-empty.
 * 
 * 2. DRIFT001: No Display-Only Fields
 *    Fields like startingAt, priceTeaser, packagePrice are banned.
 *    These must be derived at render time from the pricing SSOT.
 * 
 * 3. IMG001: Image Source Required
 *    If hero.image object exists, then hero.image.src must be non-empty.
 * 
 * EXTENSIBILITY:
 * The extras field uses .passthrough() to allow additional fields
 * for experimentation without schema changes.
 * 
 * @constant
 */
export const PackageSchema = z
  .object({
    meta: MetaSchema,
    hero: HeroSchema,
    narrative: NarrativeSchema,
    why_you_need_this: WhySchema,
    what_you_get: WhatSchema,
    details_and_trust: DetailsSchema,
    next_step: NextStepSchema,
    copy: PhaseCopySchema.optional(),
    extras: z
      .object({
        // Typed example for timeline blocks
        timeline_blocks: z
          .array(
            z.object({
              title: Str.optional(),
              note: Str.optional(),
            })
          )
          .optional(),
      })
      .passthrough() // Allow additional fields for extensibility
      .optional(),
  })
  .superRefine((pkg, ctx) => {
    // =========================================================================
    // PRC001: Pricing present ⇒ price_band.tagline required
    // =========================================================================
    // RATIONALE:
    // Taglines are marketing-critical copy that must be intentionally authored.
    // This prevents auto-generated or "stolen" copy from hero.summary.
    // Ensures brand consistency and prevents invented pricing messages.
    //
    // CHECKED BY:
    // - author-lint.ts (pre-build, fast fail)
    // - This schema (build-time, enforced)
    //
    // ERROR PATH: details_and_trust.price_band.tagline
    // =========================================================================
    const pricing = pkg.details_and_trust?.pricing;
    const hasPrice =
      (typeof pricing?.one_time === "number" && pricing.one_time > 0) ||
      (typeof pricing?.monthly === "number" && pricing.monthly > 0);

    if (hasPrice) {
      const tagline = pkg.details_and_trust?.price_band?.tagline;

      if (!tagline || !tagline.trim()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message:
            "PRC001: Pricing present but price_band.tagline is missing or empty. " +
            "Authors must provide a tagline when the package has pricing. " +
            "This is enforced to prevent invented copy and ensure brand consistency. " +
            "Add a tagline in your MDX frontmatter under detailsAndTrust.priceBand.tagline",
          path: ["details_and_trust", "price_band", "tagline"],
        });
      }
    }

    // =========================================================================
    // DRIFT001: Ban display-only fields (SSOT enforcement)
    // =========================================================================
    // RATIONALE:
    // These fields should NEVER exist in the data layer.
    // They must be derived at render time from the pricing SSOT.
    // This prevents drift between stored values and computed values.
    //
    // BANNED FIELDS:
    // - startingAt, starting_at (computed from pricing)
    // - priceTeaser, price_teaser (computed from pricing)
    // - packagePrice, package_price (computed from pricing)
    // - startingAtLabel, starting_at_label (computed from pricing)
    //
    // ERROR PATH: [field_name]
    // =========================================================================
    const bannedFields = [
      "startingAt",
      "starting_at",
      "priceTeaser",
      "price_teaser",
      "packagePrice",
      "package_price",
      "startingAtLabel",
      "starting_at_label",
    ];

    for (const fieldName of bannedFields) {
      if ((pkg as any)[fieldName] !== undefined) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message:
            `DRIFT001: Field "${fieldName}" is not allowed in package data. ` +
            `Display labels must be derived at render time from the pricing SSOT. ` +
            `Remove this field from your MDX frontmatter. ` +
            `Use pricing utilities (formatMoney, startingAtLabel) in UI components instead.`,
          path: [fieldName],
        });
      }
    }

    // =========================================================================
    // IMG001: Image source must be non-empty when image object provided
    // =========================================================================
    // RATIONALE:
    // If an image object exists, it must have a valid src.
    // Empty src would cause broken images in the UI.
    //
    // ERROR PATH: hero.image.src
    // =========================================================================
    const img = pkg.hero?.image;
    if (img && !img.src?.trim()) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          "IMG001: hero.image.src must be non-empty when image object is provided. " +
          "Either provide a valid image src or remove the image object entirely.",
        path: ["hero", "image", "src"],
      });
    }
  });

// =============================================================================
// Exported Types
// =============================================================================

/**
 * Complete package type inferred from PackageSchema.
 * 
 * Use this type throughout the application for type-safe package data.
 * All types are automatically inferred from the Zod schemas above.
 * 
 * @typedef {z.infer<typeof PackageSchema>} Package
 */
export type Package = z.infer<typeof PackageSchema>;

/**
 * Money type - pricing data structure.
 * 
 * @typedef {z.infer<typeof MoneySchema>} Money
 */
export type Money = z.infer<typeof MoneySchema>;

/**
 * Price band type - detail-page pricing copy.
 * 
 * @typedef {z.infer<typeof PriceBandSchema>} PriceBand
 */
export type PriceBand = z.infer<typeof PriceBandSchema>;

/**
 * FAQ type - question and answer pair.
 * 
 * @typedef {z.infer<typeof FaqSchema>} Faq
 */
export type Faq = z.infer<typeof FaqSchema>;

/**
 * Single include item type.
 * 
 * @typedef {z.infer<typeof IncludeItemSchema>} IncludeItem
 */
export type IncludeItem = z.infer<typeof IncludeItemSchema>;

/**
 * Include group type (collection of items).
 * 
 * @typedef {z.infer<typeof IncludeGroupSchema>} IncludeGroup
 */
export type IncludeGroup = z.infer<typeof IncludeGroupSchema>;

/**
 * Includes table type (structured comparison).
 * 
 * @typedef {z.infer<typeof IncludesTableSchema>} IncludesTable
 */
export type IncludesTable = z.infer<typeof IncludesTableSchema>;

// =============================================================================
// Validation Functions
// =============================================================================

/**
 * Strict validator - throws ZodError on validation failure.
 * 
 * Use this function at build time and in registry loaders where you
 * want to fail fast on invalid data.
 * 
 * THROWS: ZodError with detailed error information including:
 * - Field paths (e.g., "details_and_trust.price_band.tagline")
 * - Error messages (human-readable)
 * - Error codes (e.g., "PRC001")
 * 
 * @param data - Unknown data to validate against PackageSchema
 * @returns Validated Package object with full type safety
 * @throws {z.ZodError} If validation fails
 * 
 * @example
 * ```typescript
 * import { parsePackage } from './package-schema';
 * 
 * try {
 *   const pkg = parsePackage(jsonData);
 *   // pkg is now typed as Package and guaranteed valid
 *   console.log(pkg.meta.name);
 * } catch (error) {
 *   if (error instanceof z.ZodError) {
 *     console.error("Validation errors:");
 *     error.errors.forEach(err => {
 *       console.error(`  ${err.path.join('.')}: ${err.message}`);
 *     });
 *   }
 *   process.exit(1);
 * }
 * ```
 */
export function parsePackage(data: unknown): Package {
  return PackageSchema.parse(data);
}

/**
 * Safe validator - returns result object instead of throwing.
 * 
 * Use this function when validation failure should be handled gracefully,
 * such as in tests, guards, or user-facing validation.
 * 
 * RETURNS: SafeParseReturnType with:
 * - success: boolean flag
 * - data: Package (if success === true)
 * - error: ZodError (if success === false)
 * 
 * @param data - Unknown data to validate against PackageSchema
 * @returns SafeParseReturnType with success flag and data/error
 * 
 * @example
 * ```typescript
 * import { safeParsePackage } from './package-schema';
 * 
 * const result = safeParsePackage(jsonData);
 * 
 * if (result.success) {
 *   const pkg: Package = result.data;
 *   console.log("Valid package:", pkg.meta.name);
 * } else {
 *   console.error("Validation failed:");
 *   result.error.errors.forEach(err => {
 *     console.error(`  ${err.path.join('.')}: ${err.message}`);
 *   });
 * }
 * ```
 */
export function safeParsePackage(data: unknown) {
  return PackageSchema.safeParse(data);
}

// =============================================================================
// End of Schema Definition
// =============================================================================

/**
 * MAINTENANCE CHECKLIST
 * -----------------------------------------------------------------------------
 * When updating this schema:
 * 
 * 1. [ ] Update VERSION in header comments
 * 2. [ ] Run: npm run schema:build (regenerate JSON Schema)
 * 3. [ ] Run: npm run data:build (regenerate package JSONs)
 * 4. [ ] Run: npm run lint:author (validate existing packages)
 * 5. [ ] Update: docs/packages/authoring-rules.md (if rules changed)
 * 6. [ ] Update: scripts/author-lint.ts (if validation rules added)
 * 7. [ ] Run: npm test (ensure all tests pass)
 * 8. [ ] Commit: Both package-schema.ts and generated JSON Schema
 * 
 * BREAKING CHANGES:
 * - Bump major version (e.g., 2.0.0 → 3.0.0)
 * - Document migration path in CHANGELOG.md
 * - Provide migration script if data transformation needed
 * - Update all 18+ existing packages to new format
 * 
 * NON-BREAKING CHANGES:
 * - Bump minor version (e.g., 2.0.0 → 2.1.0) for new optional fields
 * - Bump patch version (e.g., 2.0.0 → 2.0.1) for bug fixes
 */